items = ask(<<-QUESTION).split(?,).map(&:strip).map(&:to_i).each do |i|
Available migratios to generate are:
  1. Timestamps for created_at/updated_at fields.
  2. Add counter cache column.
  3. Add human readable slug generation
Choose migration to generate (use comma to run several ones): (1-3):
QUESTION
  case ({ 1 => :timestamps, 2 => :counter_cache, 3 => :readable_slug })[i]
  when :timestamps
    begin
      tablename = ask("Which table should be updated with timestamps?").strip.presence || say("Table name can't be blank.") || break

      create_file "db/migrate/#{Time.now.utc.strftime("%Y%m%d%H%M%S")}_timestamps_for_#{tablename}.rb", "class TimestampsFor#{tablename.camelcase} < ActiveRecord::Migration[#{Rails::VERSION::MAJOR}.#{Rails::VERSION::MINOR}]\n  def up\n    create_or_replace_touch_functions_and_triggers_on(:insert)\n    create_or_replace_touch_functions_and_triggers_on(:update)\n    create_or_replace_touch_functions_and_triggers_on(:delete)\n  end\n\n  private\n\n  def table_names\n    %w[#{tablename}].sort\n  end\n\n  def create_or_replace_touch_functions_and_triggers_on(action)\n    table_names.each do |table_name|\n      options = touch_options_for(table_name)\n      \# next if options.none?\n\n      execute %{\n        CREATE OR REPLACE FUNCTION touch_for_\#{table_name}_on_\#{action}() RETURNS TRIGGER AS $$\n        BEGIN\#{dynamic_touch_query(options)}\n          \#{\"SELECT CURRENT_TIMESTAMP INTO NEW.updated_at;\n          \" if action == :update}RETURN \#{action == :delete ? \'OLD\' : \'NEW\'};\n        END;\n        $$ LANGUAGE plpgsql;\n      }\n\n      create_touch_trigger_for(table_name, action)\n    end\n  end\n\n  def create_touch_trigger_for(table_name, action)\n    execute %{\n      CREATE TRIGGER touch_dependent_tables_on_\#{action} BEFORE \#{action.upcase} ON \#{table_name}\n      FOR EACH ROW EXECUTE PROCEDURE touch_for_\#{table_name}_on_\#{action}();\n    }\n  end\n\n  def touch_options_for(table_name)\n    execute %(\n      SELECT ccu.table_name AS foreign_table_name, kcu.column_name AS column_name\n      FROM information_schema.table_constraints AS tc\n        JOIN information_schema.key_column_usage AS kcu\n        ON tc.constraint_name = kcu.constraint_name\n        JOIN information_schema.constraint_column_usage AS ccu\n        ON ccu.constraint_name = tc.constraint_name\n      WHERE constraint_type = \'FOREIGN KEY\' AND tc.table_name = \'\#{table_name}\'\n      ORDER BY ccu.table_name\n    )\n  end\n\n  def dynamic_touch_query(options)\n    options.inject(\'\') do |query, opts|\n      query << %(\n          UPDATE \#{opts[\'foreign_table_name\']} SET updated_at = CURRENT_TIMESTAMP WHERE id = NEW.\#{opts[\'column_name\']};)\n    end\n  end\nend\n"
    end while false
  when :counter_cache
    begin
      parent_table = ask("Set parent table which should contains count column: ").strip.presence || say("Table name can't be blank.") || break
      child_table = ask("Set a table with foreign key which one count of records should be calculated: ").strip.presence || say("Table name can't be blank.") || break
      counter_column = ask("Set counter column (by default is '#{child_table}_count'): ").strip.presence || "#{child_table}_count"
      foreign_column = ask("Set foreign column (by default is '#{parent_table.singularize}_id'): ").strip.presence || "#{child_table.singularize}_id"

      create_file "db/migrate/#{Time.now.utc.strftime("%Y%m%d%H%M%S")}_add_counter_cache_to_#{parent_table}_for_#{child_table}.rb", "class AddСounterСacheTo#{parent_table.camelcase}For#{child_table.camelcase} < ActiveRecord::Migration[#{Rails::VERSION::MAJOR}.#{Rails::VERSION::MINOR}]\n  def change\n    counter_trigger(parent_table: :#{parent_table}, child_table: :#{child_table}, counter_column: :#{counter_column}, foreign_column: :#{foreign_column})\n  end\n\n  def counter_trigger(parent_table:, child_table:, counter_column:, foreign_column:)\n    function_name = \"update_\#{parent_table}_\#{child_table}_counter\"\n    execute %{\n      CREATE OR REPLACE FUNCTION \#{function_name}_on_insert() RETURNS TRIGGER AS $$\n      BEGIN\n        UPDATE \#{parent_table} SET \#{counter_column} = COALESCE((SELECT COUNT(id) FROM \#{child_table} GROUP BY \#{foreign_column} HAVING \#{foreign_column} = NEW.\#{foreign_column}), 0) WHERE (\#{parent_table}.id = NEW.\#{foreign_column});\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n\n      CREATE OR REPLACE FUNCTION \#{function_name}_on_delete() RETURNS TRIGGER AS $$\n      BEGIN\n        UPDATE \#{parent_table} SET \#{counter_column} = COALESCE((SELECT COUNT(id) FROM \#{child_table} GROUP BY \#{foreign_column} HAVING \#{foreign_column} = OLD.\#{foreign_column}), 0) WHERE (\#{parent_table}.id = OLD.\#{foreign_column});\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n\n      CREATE OR REPLACE FUNCTION \#{function_name}_on_update() RETURNS TRIGGER AS $$\n      BEGIN\n        IF NEW.\#{foreign_column} <> OLD.\#{foreign_column} THEN\n          UPDATE \#{parent_table} SET \#{counter_column} = COALESCE((SELECT COUNT(id) FROM \#{child_table} GROUP BY \#{foreign_column} HAVING \#{foreign_column} = NEW.\#{foreign_column}), 0) WHERE (\#{parent_table}.id = NEW.\#{foreign_column});\n          UPDATE \#{parent_table} SET \#{counter_column} = COALESCE((SELECT COUNT(id) FROM \#{child_table} GROUP BY \#{foreign_column} HAVING \#{foreign_column} = OLD.\#{foreign_column}), 0) WHERE (\#{parent_table}.id = OLD.\#{foreign_column});\n        END IF;\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n\n      CREATE TRIGGER _001_\#{function_name}_on_insert AFTER INSERT ON \#{child_table} FOR EACH ROW EXECUTE PROCEDURE \#{function_name}_on_insert();\n      CREATE TRIGGER _001_\#{function_name}_on_update AFTER UPDATE ON \#{child_table} FOR EACH ROW EXECUTE PROCEDURE \#{function_name}_on_update();\n      CREATE TRIGGER _001_\#{function_name}_on_delete AFTER DELETE ON \#{child_table} FOR EACH ROW EXECUTE PROCEDURE \#{function_name}_on_delete();\n    }\n  end\nend\n"
    end while false
  when :readable_slug
    begin
      is_append = ["n", "no"].include?(ask("Is this first time whene you add slug to this project? Y/n").strip.presence.downcase)
      tablename = ask("Which table should have readable slug?").strip.presence || say("Table name can't be blank.") || break
      slug_prefix = ask("Choose slug prefix (a couple of letters length is preferred):") || say("Slug prefix can't be blank") || break

      create_file "db/migrate/#{Time.now.utc.strftime("%Y%m%d%H%M%S")}_add_human_readable_slug_generation_to_#{tablename}.rb", (is_append ? "class AddHumanReadableSlugGenerationTo#{tablename.camelcase} < ActiveRecord::Migration[#{Rails::VERSION::MAJOR}.#{Rails::VERSION::MINOR}]\n  def up\n    add_column :prefix_sequence_list, :#{tablename}_sequence_reseted, :boolean, default: false\n    change_column :#{tablename}, :slug, :string\n\n    execute(\n      <<~SQL\n        CREATE SEQUENCE #{tablename}_daily_seq OWNED BY prefix_sequence_list.key;\n\n        CREATE OR REPLACE FUNCTION human_slug_for_#{tablename}() RETURNS TRIGGER AS $$\n        BEGIN\n          SELECT generate_slug(\'#{tablename}\'::regclass, \'CC\', \'#{tablename}_daily_seq\') INTO NEW.slug;\n          RETURN NEW;\n        END;\n        $$ LANGUAGE plpgsql;\n\n        CREATE TRIGGER generate_human_slug_for_#{tablename}_on_insert BEFORE INSERT ON #{tablename}\n        FOR EACH ROW EXECUTE PROCEDURE human_slug_for_#{tablename}();\n      SQL\n    )\n\n    execute(\n      <<~SQL\n        UPDATE credit_cards SET slug = CONCAT(\'#{slug_prefix}-AAA-\', id);\n      SQL\n    )\n  end\nend\n" : "class AddHumanReadableSlugGenerationTo#{tablename.camelcase} < ActiveRecord::Migration[#{Rails::VERSION::MAJOR}.#{Rails::VERSION::MINOR}]\n  VOWELS = %w[A E I O U Y].freeze\n  CONSONANTS = %w[B C D F G H J K L M N P Q R S T V W X Z].freeze\n  SEED = #{38.times.map { |i| rand(10) }.join}\n\n  def up\n    add_tables_and_columns\n    create_static_sql_functions\n\n    execute(\n      <<~SQL\n        CREATE SEQUENCE #{tablename}_daily_seq OWNED BY prefix_sequence_list.key;\n\n        CREATE OR REPLACE FUNCTION human_slug_for_#{tablename}() RETURNS TRIGGER AS $$\n        BEGIN\n          SELECT generate_slug(\'#{tablename}\'::regclass, \'#{slug_prefix}\', \'#{tablename}_daily_seq\') INTO NEW.slug;\n          RETURN NEW;\n        END;\n        $$ LANGUAGE plpgsql;\n\n        CREATE TRIGGER generate_human_slug_for_#{tablename}_on_insert BEFORE INSERT ON #{tablename}\n        FOR EACH ROW EXECUTE PROCEDURE human_slug_for_#{tablename}();\n      SQL\n    )\n\n    generate_prefixes\n    update_existing_records\n    update_columns\n  end\n\n  private\n\n  def add_tables_and_columns\n    create_table :prefix_sequence_list do |t|\n      t.date :key, null: false\n      t.string :sequence, null: false\n      t.boolean :#{tablename}_sequence_reseted, null: false, default: false\n    end\n    \# or add column if table already exists\n    \# add_column :prefix_sequence_list, :#{tablename}_sequence_reseted, :boolean, null: false, default: false\n\n    add_index :prefix_sequence_list_for_#{tablename}, :key, unique: true\n    add_column :#{tablename}, :slug, :string\n  end\n\n  def update_columns\n    change_column_null :#{tablename}, :slug, false\n    add_index :#{tablename}, :slug, unique: true\n  end\n\n  def generate_prefixes\n    codes = VOWELS.each_with_object([]) do |a, obj|\n      CONSONANTS.each { |b| CONSONANTS.each { |c| obj.push(\"\#{b}\#{a}\#{c}\") } }\n    end\n\n    start_date = Date.yesterday\n\n    values = codes.shuffle(random: Random.new(SEED)).map do |code|\n      start_date = start_date.tomorrow\n      %((\'\#{start_date}\', \'\#{code}\'))\n    end\n\n    execute(\n      <<~SQL\n        INSERT INTO prefix_sequence_list_for_#{tablename} (\"key\", \"#{tablename}\") VALUES \#{values.join(\', \')};\n      SQL\n    )\n  end\n\n  def update_existing_records\n    execute(\n      <<~SQL\n        UPDATE #{tablename} SET slug = CONCAT(\'#{slug_prefix}-AAA-\', id) WHERE slug IS NULL;\n      SQL\n    )\n  end\n\n  def create_static_sql_functions\n    execute(\n      <<~SQL\n        CREATE OR REPLACE FUNCTION generate_slug(table_name regclass, prefix TEXT, seq_name TEXT) RETURNS TEXT AS $$\n        DECLARE\n          daily_code TEXT;\n        BEGIN\n          SELECT fetch_daily_code(table_name, seq_name) INTO daily_code;\n\n          RETURN CONCAT_WS(\'-\', prefix, daily_code, nextval(seq_name));\n        END;\n        $$ LANGUAGE plpgsql;\n\n        CREATE OR REPLACE FUNCTION fetch_daily_code(table_name regclass, seq_name TEXT) RETURNS TEXT AS $$\n        DECLARE\n          prefix_sequence_list_id prefix_sequence_list.id%TYPE;\n          daily_code TEXT;\n          used BOOLEAN;\n        BEGIN\n          EXECUTE format(\'SELECT sl.id, sl.sequence, sl.%s_sequence_reseted FROM prefix_sequence_list AS sl WHERE sl.key = now()::date LIMIT 1;\', table_name) INTO prefix_sequence_list_id, daily_code, used;\n\n          IF NOT used THEN\n            EXECUTE format(\'UPDATE prefix_sequence_list AS sl SET %s_sequence_reseted = TRUE WHERE sl.id = %s;\', table_name, prefix_sequence_list_id);\n            EXECUTE format(\'ALTER SEQUENCE %s RESTART WITH 1;\', seq_name);\n          END IF;\n\n          RETURN daily_code;\n        END;\n        $$ LANGUAGE plpgsql;\n      SQL\n    )\n  end\nend\n")
    end while false
  else
    puts "Nothing to generate"
  end
end
